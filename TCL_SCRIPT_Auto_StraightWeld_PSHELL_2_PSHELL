# THIS IS FOR STRAITGHT WELD BETWEN 2 PSHELL COMPS
proc StraightBetweenPshell {} {

#package require hwat;

*saveviewmask "tempView" 0
*createmarkpanel nodes 1 "select 2 nodes";

set twoNodeId [hm_getmark nodes 1];

*nodemarkbypath [lindex $twoNodeId 0] [lindex $twoNodeId 1] 2;
set allNode [hm_getmark nodes 2];
#puts $allNode;

# GET NODE FOR ISOLATING ELEMENTS
	if {1} {
		*markdifference nodes 2 nodes 1;
		set nodeId [hm_getmark nodes 2];
		#puts "NODE ID"; puts $nodeId;
	}
	
# GET TARGET COMP ID
	if {1} {
		*createmarkpanel comp 1 "select comp";
		set compId [hm_getmark comp 1];
		
	}
# GET NODE CLOSET
	if {1} {
		*createmark nodes 1 "by comp" $compId;
		set tempNode [hm_getmark node 1];
		
		set targetNodeId {};
		
		*createmark elem 1 "by comp" $compId;
		eval *createmark node 1 $allNode;
		foreach id $nodeId {
		
			lappend targetNodeId [eval hm_getclosestnode [hm_getvalue node id=$id dataname=coordinates] 1 1]
			
			#puts $targetNodeId;	
		}
		*clearmarkall 1; *clearmarkall 2;
		
	}
	
	
# ISOLATE ELEM FOR WELDING
	if {1} {
		# At this stage, we separate elem for create profile and isolate them;
			#GET ELEM FROM PSHELL 1;
				if {1} {
					eval *createmark node 1 $nodeId
					*findmark node 1 1 1 elem 0 2;
					set initial_elem1 [hm_getmark elem 2];
					
					#puts $initial_elem1; 
					
					set pshell1Elem {};
					foreach elem $initial_elem1 {
						if {[hm_getvalue elem id=$elem dataname=config] == 104} {
							lappend pshell1Elem $elem;
						}
					}
				}
			#GET ELEM FROM PSHELL 2;
				if {1} {
					eval *createmark node 1 $targetNodeId
					*findmark node 1 1 1 elem 0 2;
					set initial_elem2 [hm_getmark elem 2];
					set pshell2Elem {};
					foreach elem $initial_elem2 {
						if {[hm_getvalue elem id=$elem dataname=config] == 104} {
							lappend pshell2Elem $elem;
						}
					}
					
				}	
		eval *createmark elem 2 $pshell1Elem $pshell2Elem;
		*isolateonlyentitybymark 2;
	
		*clearmarkall 1; *clearmarkall 2;
	}
	
# CREATE PROFILE
	if {1} {
		
		# CREATE PROFILE
			if {1} {
				set quad1 [list 0 0 0 0];
				set quad2 [list 0 0 0 0];
				set tria1 [list 0 0 0];
				set tria2 [list 0 0 0];
				
				# GET NODES FOR QUAD1
					if {1} {
						eval *createmark elem 1 $pshell1Elem;
						lset quad1 0 [lindex $twoNodeId 0];
						eval *createmark node 1 $allNode;
						lset quad1 1 [eval hm_getclosestnode [hm_getvalue node id=[lindex $twoNodeId 0]	dataname=coordinates] 1 1]
						eval *createmark elem 1 $pshell2Elem;
						lset quad1 2 [eval hm_getclosestnode [hm_getvalue node id=[lindex $twoNodeId 0]	dataname=coordinates] 1 1]
						lset quad1 3 [eval hm_getclosestnode [hm_getvalue node id=[lindex $quad1 1]	dataname=coordinates] 1 1]
					}
				# GET NODES FOR QUAD2
					if {1} {
						eval *createmark elem 1 $pshell1Elem;
						lset quad2 0 [lindex $twoNodeId 1];
						eval *createmark node 1 $allNode;
						lset quad2 1 [eval hm_getclosestnode [hm_getvalue node id=[lindex $twoNodeId 1]	dataname=coordinates] 1 1]
						eval *createmark elem 1 $pshell2Elem;
						lset quad2 2 [eval hm_getclosestnode [hm_getvalue node id=[lindex $twoNodeId 1]	dataname=coordinates] 1 1]
						lset quad2 3 [eval hm_getclosestnode [hm_getvalue node id=[lindex $quad2 1]	dataname=coordinates] 1 1]
					}
				# GET NODES FOR TRIAs
					if {1} {
						lset tria1 0 [lindex $quad1 0];
						lset tria1 1 [lindex $quad1 2];
						
						lset tria2 0 [lindex $quad2 0];
						lset tria2 1 [lindex $quad2 2];
						*nodemarkbypath [lindex $quad1 3] [lindex $quad2 3] 1;
						set temp1_node [hm_getmark nodes 1];
						eval lappend temp1_node $targetNodeId;
						lappend temp1_node [lindex $quad1 2] [lindex $quad2 2];
						
						# GET NODES FOR TRIAs
							if {1} {
								eval *createmark elem 1 $pshell2Elem;
								eval *createmark nodes 1 $temp1_node;
								lset tria1 2 [eval hm_getclosestnode [hm_getvalue node id=[lindex $twoNodeId 0]	dataname=coordinates] 1 1];
								lset tria2 2 [eval hm_getclosestnode [hm_getvalue node id=[lindex $twoNodeId 1]	dataname=coordinates] 1 1]
							}
					}
				
			}
	

		
		# CREATE SOURCE ELEMS
		if {1} {
			# CHECK THE EXISTANCE OF SOURCE COMPONENT
			if {1} {
				# CREATE A TEMPORARY COMPONENTS
					if {[hm_entityinfo exist comp "COMP_SOURCE" -byname]} {
						*currentcollector components "COMP_SOURCE";
					} else {
						*createentity comps name=COMP_SOURCE;
					}
			}
			
			if {1} {	
				eval *createlist nodes 2 $tria1;
				*createelement 103 1 2 1;
				eval *createlist nodes 2 $quad1;
				*createelement 104 1 2 1;
				
			}
		}
		# CREATE DESTINATION ELEMS
		if {1} {
			# CHECK THE EXISTANCE OF SOURCE COMPONENT
			if {1} {
				# CREATE A TEMPORARY COMPONENTS
					if {[hm_entityinfo exist comp DESTINATION -byname]} {
						*currentcollector components "DESTINATION";
					} else {
						*createentity comps name=DESTINATION;
					}
			}
			
			if {1} {	
				eval *createlist nodes 2 $tria2;
				*createelement 103 1 2 1;
				eval *createlist nodes 2 $quad2;
				*createelement 104 1 2 1;
				
			}
		}
	
	}
	
	

# WELDING
	if {1} {
	
			*clearmarkall 1; *clearmarkall 2;
			
			*solidmap_begin 0
			*solidmap_prepare_usrdataptr "SOURCE" 8
			*createmark elements 1 "by comp name" "COMP_SOURCE"
			*solid_prepare_entitylst elements 0
			*solidmap_prepare_usrdataptr "DEST" 8
			*createmark elements 1 "by comp name" "DESTINATION"
			*solid_prepare_entitylst elements 0
			*solidmap_prepare_usrdataptr "ALONG" 15
			eval *createmark elems 1 $pshell1Elem $pshell2Elem;
	
			*solid_prepare_entitylst elements 0
			*solidmap_end 8322 10 0 0
	}

	*clearmarkall 1; *clearmarkall 2;
}

if {1} {
	StraightBetweenPshell;
	
	# CHECK THE EXISTANCE OF PSO_WELD COMPONENT
		if {1} {
			# CREATE A TEMPORARY COMPONENTS
				if {[hm_entityinfo exist comp PSO_WELD -byname]} {
					*currentcollector components "PSO_WELD";
				} else {
					*createentity comps name=PSO_WELD;
				}
		}
		# MOVE ELEMS TO WELD COMP;
		if {1} {
			*createmark elem 1 "by comp" "solidmap";
			if {[hm_marklength elem 1]} {
			*movemark elements 1 "PSO_WELD";
			}
		}
		# DELETE COMP_SOURCE & DESTINATION
		if {1 } {
			*createmark components 1 "COMP_SOURCE" "DESTINATION";
			*deletemark components 1
		}
		# CHECK DUPLICATE AND DELETE
		if {1} {
			*createmark elements 1 "all"
			*createmark elements 2
			*elementtestduplicates elements 1 2 4
			if {[hm_marklength elem 2] != 0} {
				*deletemark elem 2;
			}

		}
		*restoreviewmask "tempView" 0
		*removeview "tempView"
}
