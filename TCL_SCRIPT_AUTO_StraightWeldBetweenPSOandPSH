#AUTO WELD BETWEN PSO AND PSH: 1 HEX + 2 PEN
proc StraightWeld_PSO_2_PSH {} {
# PICK 2 NODE, CREATE COMP "^face", GET ELEMS FROM COMP "^face";
puts "=================WELD BETWEEN PSO AND PSH: 1HEX + 2 PEN======================"

# INITIAL STEPS
	if {1} {
	
		*saveviewmask "tempView" 0
		*createmarkpanel nodes 1 "select 2 nodes";

		set twoNodeId [hm_getmark nodes 1];

		*nodemarkbypath [lindex $twoNodeId 0] [lindex $twoNodeId 1] 2;
		set allNode [hm_getmark nodes 2];
		# if {[llength $allNode] != 2} {
			# puts "NEED 2 NODES ONLY";
			# return;
		# }
	}

# GET NODE FOR ISOLATING ELEMENTS
	if {1} {
		*markdifference nodes 2 nodes 1;
		set nodeId [hm_getmark nodes 2];

	}
# GET TARGET COMP ID
	if {1} {
		*createmarkpanel comp 1 "select comp";
		set compId [hm_getmark comp 1];
		
		# if {[llength $compId] == 0} {
			# puts "NEED TO SELECT TARGET COMP";
			# return;
		# }
	}
#	GET PSO COMP ID TO CREATE "^face" COMP;

	if {1} {
		# GET ID OF PSO COMP
			*createmark node 1 [lindex $twoNodeId 0];
			*findmark node 1 1 1 elem 0 2;
			set temp [hm_getmark elem 2];
			set temp2 [lindex $temp 0];
			set id_PSO [hm_getvalue elem id = $temp2 dataname=collector.id];
			unset temp; unset temp2;
		# FIND FACE FOR PSO COMP
		# CREATE A TEMPORARY COMPONENTS
			if {[hm_entityinfo exist comp "^face" -byname]} {
				*createmark components 1 "^face";
				*deletemark components 1;
			}
			*createmark components 1 $id_PSO;
			*findfaces components 1;
	
	}
# ISOLATE ELEMENTS FROM "^face" COMP
	if {1} {
	
		eval *createmark nodes 1 $nodeId;
		*findmark node 1 1 1 elem 0 2;
		set initial_elem1 [hm_getmark elem 2];
		
		set pshell1Elem {};
		foreach elem $initial_elem1 {
			if {[hm_getvalue elem id=$elem dataname=config] == 104} {
					lappend pshell1Elem $elem;
			}
		}
	}
	


	
# GET NODE CLOSET
	if {1} {
		*createmark nodes 1 "by comp" $compId;
		set tempNode [hm_getmark node 1];
		
		set targetNodeId {};
		
		*createmark elem 1 "by comp" $compId;
		eval *createmark node 1 $allNode;
		foreach id $nodeId {
		
			lappend targetNodeId [eval hm_getclosestnode [hm_getvalue node id=$id dataname=coordinates] 1 1]
			
			#puts $targetNodeId;	
		}
		*clearmarkall 1; *clearmarkall 2;
		
	}
		
	
#GET ELEM FROM PSHELL 2;	
	if {1} {
		eval *createmark node 1 $targetNodeId
		*findmark node 1 1 1 elem 0 2;
		set initial_elem2 [hm_getmark elem 2];
		set pshell2Elem {};
		foreach elem $initial_elem2 {
			if {[hm_getvalue elem id=$elem dataname=config] == 104} {
				lappend pshell2Elem $elem;
			}
		}
	}

# ISOLATE ELEMS
		if {1} {
			eval *createmark elem 2 $pshell1Elem $pshell2Elem;
			*isolateonlyentitybymark 2;

			*clearmarkall 1; *clearmarkall 2;
		}
		
# GET NODE LSIT 1
	if {1} {
		eval *createmark node 1 $allNode;
		eval *createmark elem 2 $pshell1Elem;
		set list1 {}; # list of first-closet node
		foreach id $allNode {
			lappend list1 [eval hm_getclosestnode [hm_getvalue node id=$id dataname=coordinates] 2 1]
		}
	}
	
# GET NODE LIST2 : LIST OF SECOND-CLOSE NODES
	if {1} {
		eval *createmark node 1 $allNode $list1;
		eval *createmark elem 2 $pshell1Elem;
		set list2 {}; # list of first-closet node
		foreach id $allNode {
			lappend list2 [eval hm_getclosestnode [hm_getvalue node id=$id dataname=coordinates] 2 1]
		}
	}
	
# GET NODE LIST3 : LIST OF NODES CLOSEST TO allNode
	if {1} {
		eval *createmark node 1 $allNode $list1 $list2;
		eval *createmark elem 2 $pshell2Elem;
		set list3 {}; # list of first-closet node
		foreach id $allNode {
			lappend list3 [eval hm_getclosestnode [hm_getvalue node id=$id dataname=coordinates] 2 1]
		}
	}
	
# GET NODE LIST4 : LIST OF NODES CLOSEST TO list2
	if {1} {
		eval *createmark node 1 $allNode $list1 $list2 $list3;
		eval *createmark elem 2 $pshell2Elem;
		set list4 {}; # list of first-closet node
		foreach id $list2 {
			lappend list4 [eval hm_getclosestnode [hm_getvalue node id=$id dataname=coordinates] 2 1]
		}
	}
# GET NODE LIST5 : LIST OF NODES CLOSEST TO list2
	if {1} {
		eval *createmark node 1 $allNode $list1 $list2 $list3 $list4;
		eval *createmark elem 2 $pshell2Elem;
		set list5 {}; # list of first-closet node
		foreach id $list3 {
			lappend list5 [eval hm_getclosestnode [hm_getvalue node id=$id dataname=coordinates] 2 1]
		}
	}
	
# CREATE PROFILE
	if {1} {
	
		# INITIALIZATION
			if {1} {
				set quad1 [list 0 0 0 0];
				set tria1 [list 0 0 0];
				set tria2 [list 0 0 0];
				set quad2 [list 0 0 0 0];
				set tria3 [list 0 0 0];
				set tria4 [list 0 0 0];
			}
		# GET NODES FOR QUAD1
			if {1} {
				# FIRST NODES
				lset quad1 0 [lindex $twoNodeId 0]; # first node of quad1
				# SECOND
				eval *createmark elem 1 $pshell1Elem;
				eval *createmark nodes 1 $allNode $list1;
				lset quad1 1 [eval hm_getclosestnode [hm_getvalue node id=[lindex $twoNodeId 0]	dataname=coordinates] 1 1]
				# THIRD
				eval *createmark elem 1 $pshell2Elem;
				eval *createmark nodes 1 $allNode $list1 $list2 $list4 $list5;
				lset quad1 2 [eval hm_getclosestnode [hm_getvalue node id=[lindex $twoNodeId 0]	dataname=coordinates] 1 1]

				# FOUTH
				eval *createmark elem 1 $pshell2Elem;
				eval *createmark nodes 1 $allNode $list1 $list2 $list3 $list5;
				lset quad1 3 [eval hm_getclosestnode [hm_getvalue node id=[lindex $quad1 1]	dataname=coordinates] 1 1];

			}
			
		# GET NODES FOR QUAD 2
			if {1} {
				# FIRST NODE
				lset quad2 0 [lindex $twoNodeId 1];
				# SECOND
				eval *createmark elem 1 $pshell1Elem;
				eval *createmark nodes 1 $allNode $list1;
				lset quad2 1 [eval hm_getclosestnode [hm_getvalue node id=[lindex $twoNodeId 1]	dataname=coordinates] 1 1];
				# THIRD
				eval *createmark elem 1 $pshell2Elem;
				eval *createmark nodes 1 $allNode $list1 $list2 $list4 $list5;
				set temp {};
				lset quad2 2 [eval hm_getclosestnode [hm_getvalue node id=[lindex $twoNodeId 1]	dataname=coordinates] 1 1];

				# FOUTH
				eval *createmark elem 1 $pshell2Elem;
				eval *createmark nodes 1 $allNode $list1 $list2 $list3 $list5;
	
				lset quad2 3 [eval hm_getclosestnode [hm_getvalue node id=[lindex $quad2 1]	dataname=coordinates] 1 1];

			}
		# GET NODES FOR TRIA1
			if {1} {
				lset tria1 0 [lindex $twoNodeId 0];
				lset tria1 1 [lindex $quad1 2];
				
				eval *createmark elem 1 $pshell2Elem;
				eval *createmark nodes 1 $allNode $list1 $list2 $list3 $list4;

				lset tria1 2 [eval hm_getclosestnode [hm_getvalue node id=[lindex $quad1 1]	dataname=coordinates] 1 1];
				
			}
		# GET NODES FOR TRIA2
			if {1} {
				lset tria2 0 [lindex $twoNodeId 0];
				lset tria2 2 [lindex $tria1 2];
				
				*clearmarkall 1; *clearmarkall 2;
				eval *createmark elem 2 $pshell1Elem;
				eval *createmark nodes 1 $allNode $list5 $list2 $list3 $list4;
				lset tria2 1 [eval hm_getclosestnode [hm_getvalue node id=[lindex $twoNodeId 0]	dataname=coordinates] 2 1];
				
			}
		# GET NODES FOR TRIA3
			if {1} {
				lset tria3 0 [lindex $twoNodeId 1];
				lset tria3 1 [lindex $quad2 2];
				
				eval *createmark elem 1 $pshell2Elem;
				eval *createmark nodes 1 $allNode $list1 $list2 $list3 $list4;
				set temp {};
				set temp [eval hm_getclosestnode [hm_getvalue node id=[lindex $quad2 1]	dataname=coordinates] 1 1];
				lset tria3 2 $temp; unset temp;
			}
		# GET NODES FOR TRIA4
			if {1} {
				lset tria4 0 [lindex $twoNodeId 1];
				lset tria4 2 [lindex $tria3 2];
				
				eval *createmark elem 2 $pshell1Elem;
				eval *createmark nodes 1 $allNode $list5 $list2 $list3 $list4;
				lset tria4 1 [eval hm_getclosestnode [hm_getvalue node id=[lindex $twoNodeId 1]	dataname=coordinates] 2 1];

			}
		#======================================================
		# CREATE SOURCE ELEMS
		if {1} {
			# CHECK THE EXISTANCE OF SOURCE COMPONENT
			if {1} {
				# CREATE A TEMPORARY COMPONENTS
					if {[hm_entityinfo exist comp "COMP_SOURCE" -byname]} {
						*createmark components 1 "COMP_SOURCE"
						*deletemark components 1;
						*createentity comps name=COMP_SOURCE;
						#*currentcollector components "COMP_SOURCE";
					} else {
						*createentity comps name=COMP_SOURCE;
					}
			}
			
			if {1} {	
				eval *createlist nodes 2 $tria1;
				*createelement 103 1 2 1;
				eval *createlist nodes 2 $tria2;
				*createelement 103 1 2 1;
				eval *createlist nodes 2 $quad1;
				*createelement 104 1 2 1;
				
			}
		}
		# CREATE DESTINATION ELEMS
		if {1} {
			# CHECK THE EXISTANCE OF SOURCE COMPONENT
			if {1} {
				# CREATE A TEMPORARY COMPONENTS
					if {[hm_entityinfo exist comp DESTINATION -byname]} {
						*createmark components 1 "DESTINATION";
						*deletemark components 1;
						*createentity comps name=DESTINATION;
						#*currentcollector components "DESTINATION";
					} else {
						*createentity comps name=DESTINATION;
					}
			}
			
			if {1} {	
				eval *createlist nodes 2 $tria3;
				*createelement 103 1 2 1;
				eval *createlist nodes 2 $tria4;
				*createelement 103 1 2 1;
				eval *createlist nodes 2 $quad2;
				*createelement 104 1 2 1;
				
			}
		}
	}
	
# WELDING
	if {1} {
	
			*clearmarkall 1; *clearmarkall 2;
			
			*solidmap_begin 0
			*solidmap_prepare_usrdataptr "SOURCE" 8
			*createmark elements 1 "by comp name" "COMP_SOURCE"
			*solid_prepare_entitylst elements 0
			*solidmap_prepare_usrdataptr "DEST" 8
			*createmark elements 1 "by comp name" "DESTINATION"
			*solid_prepare_entitylst elements 0
			*solidmap_prepare_usrdataptr "ALONG" 15
			eval *createmark elems 1 $pshell1Elem $pshell2Elem;
	
			*solid_prepare_entitylst elements 0
			*solidmap_end 8322 10 0 0
	}

	*clearmarkall 1; *clearmarkall 2;
	puts "=================FINISHED======================"
}

# EXCUTION
if {1} {
	StraightWeld_PSO_2_PSH;
	
	# CHECK THE EXISTANCE OF PSO_WELD COMPONENT
		if {1} {
			# CREATE A TEMPORARY COMPONENTS
				if {[hm_entityinfo exist comp PSO_WELD -byname]} {
					*currentcollector components "PSO_WELD";
				} else {
					*createentity comps name=PSO_WELD;
				}
		}
		# MOVE ELEMS TO WELD COMP;
		if {1} {
			*createmark elem 1 "by comp" "solidmap";
			if {[hm_marklength elem 1]} {
			*movemark elements 1 "PSO_WELD";
			}
		}
		# DELETE COMP_SOURCE & DESTINATION
		if {1 } {
			*createmark components 1 "COMP_SOURCE" "DESTINATION" "^face";
			*deletemark components 1
		}
		# CHECK DUPLICATE AND DELETE
		if {1} {
			*createmark elements 1 "all"
			*createmark elements 2
			*elementtestduplicates elements 1 2 4
			if {[hm_marklength elem 2] != 0} {
				*deletemark elem 2;
			}

		}
		#*unmaskall2 
		*restoreviewmask "tempView" 0
		*removeview "tempView"
}
